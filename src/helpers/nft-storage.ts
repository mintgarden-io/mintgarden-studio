import crypto from 'crypto';
import { File, NFTStorage } from 'nft.storage';
import { build, validate } from 'ucan-storage/ucan-storage';
import { KeyPair } from 'ucan-storage/keypair';
import * as ed from '@noble/ed25519';
import axios from 'axios';
import { StorageCapability } from 'ucan-storage/types';
import Store from 'electron-store';

const MINTGARDEN_BACKEND = 'http://localhost:8000/'; // TODO


export class NftStorageUploader {
  async upload(file: { name: string; type: string; content: Buffer }, metadata: { [key: string]: any }) {
    const dataFileName = file.name;
    const dataContent = file.content;
    const dataHash = crypto.createHash('sha256').update(dataContent).digest('hex');
    const dataFile = new File([dataContent], dataFileName, { type: file.type });

    const metadataString = JSON.stringify(metadata, null, 2);
    const metadataHash = crypto.createHash('sha256').update(metadataString).digest('hex');
    const metadataFile = new File([metadataString], 'metadata.json', {
      type: 'application/json',
    });

    const store = new Store();
    const UCAN_PK_SLOT = "ucan_private_key";

    const fromHexString = (hexString: String) =>
      Uint8Array.from(hexString.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)));

    const toHexString = (bytes: Uint8Array) =>
      bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');


    let userKeyPair: KeyPair;
    if (store.has(UCAN_PK_SLOT)) {
      const userPrivateKey = fromHexString(store.get(UCAN_PK_SLOT) as String);
      userKeyPair = await loadKeyPair(userPrivateKey);
    } else {
      userKeyPair = await createNewKeypair();
      store.set(UCAN_PK_SLOT, toHexString(userKeyPair.privateKey));
    }

    const url = MINTGARDEN_BACKEND + 'ucan/token';
    const res = await axios({
      method: 'post',
      url: url,
      data: { user_did: userKeyPair.did() },
    });
    const parentUCAN = res['data']['derived_token']; // generated by mint garden's backend, that creates this token by deriving its root UCAN token

    const requestToken = await createRequestToken(parentUCAN, userKeyPair);

    const client = new NFTStorage({
      token: requestToken,
    });
    const cid = await client.storeDirectory([dataFile, metadataFile]);
    console.log(`Files uploaded to nft storage: https://nftstorage.link/ipfs/${cid}`)
    return {
      dataUris: [
        `https://nftstorage.link/ipfs/${cid}/${encodeURIComponent(dataFileName)}`,
        `ipfs://${cid}/${encodeURIComponent(dataFileName)}`,
      ],
      dataHash,
      metadataUris: [`https://nftstorage.link/ipfs/${cid}/metadata.json`, `ipfs://${cid}/metadata.json`],
      metadataHash,
    };
  }
}

async function createNewKeypair() {
  return await KeyPair.create();
}

async function loadKeyPair(privateKey: Uint8Array) {
  const publicKey = await ed.getPublicKey(privateKey);
  return new KeyPair(privateKey, publicKey);
}

async function createRequestToken(parentUCAN: string, issuerKeyPair: KeyPair) {
  // we want to include the capabilities of the parent token in our request token
  // so we validate the parent token to extract the payload and copy over the capabilities
  const { payload } = await validate(parentUCAN);

  // the `att` field contains the capabilities we need for uploading
  const att = payload.att as StorageCapability[];

  const nftSTorageDid = await getNftStorageDid();

  return build({
    issuer: issuerKeyPair,
    audience: nftSTorageDid,
    capabilities: att,
    proofs: [parentUCAN],
    lifetimeInSeconds: 3600 * 24 * 365, // the limiting factor will be the life time of the root ucan,
  });
}

async function getNftStorageDid() {
  const res = await axios({
    method: 'get',
    url: `https://api.nft.storage/did`,
    data: {},
  });
  return res.data.value;
}
